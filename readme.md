# 编程记录

1. 值类型与引用类型，《The way to go》写这么一句话，struct是值类型so可以使用new创建。乍听很怪的一句话，为什么值类型要用new，不是对象引用类型才new吗？理解这句话就理解了golang整个的指针逻辑。因为值是值所以需要new()拿到指针，而引用既是指针则不需要new()拿指针，而是初始化它。  
2. 系统错误异常程序不可处理，runtime异常不需要捕获因为需要check,非runtime异常需要捕获因为程序逻辑处理的一部份。  
3. Golang仿佛是js的底层版，解决了很多js存在的问题，比如err优先机制，回调黑洞。很多情况下，一个异步函数直接吧整个项目带进异步中，返回值再也捞不出来，await我认为是一种语法糖至少本质没有变，之后还是要.then中。golang而是使用返回值标识直接捞出。  
4. What's闭包？闭包是一个函数式编程的class，所以函数式编程面向对象编程这里都是在解决一个问题，抽象复用逻辑。  
5. Golang自定义Error，通过自定义类型实现接口来Error，可配置级别的Error。  
6. 指针可控，是不是来说和其他语言交互数据也是很方便，比较计算机内存是共用的。 
7. 共享信道，而不是共享内存。  
### 8.接口和方法：
-- 不必让 一个类型 实现多个接口（排序和打印）， 我们可通过将数据条目转换为多种类型（Sequence、sort.IntSlice 和 []int）来使用相应的功能，每次转换都完成一部分工作。 这在实践中虽然有些不同寻常，但往往却很有效。  
-- 类型转换、类型断言: 
--- x.(T) x是接口类型，T是具体类型，断言转化为具体类型T
--- x.(T) x是接口类型，T是接口类型，转化为接口T，即方法集变化，失败是T的零值  
-- 类型开关：  
--- switch x := x.(type)
-- interface{}, 可识别联合
-- 接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。
-- 当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好方式。
-- 对于接口设计的一个好的标准就是 ask only for what you need
### 9. Go程：  
-- 不要通过共享内存来通信，而应通过通信来共享内存。
### 10. Error：  
-- PathError{ Op: "open", Path: "/no/such/file", Err: 0x2}  

### 11. Panic与恢复：  
### 12. Test:  